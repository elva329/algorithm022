## Data Structure
* Array
* Stack/Queue
* PriorityQueue(heap)
* LinkedList(single/double)
* Tree/Binary Tree
* Binary Search Tree
* HashTable
* Disjoint Set
* Trie
* BloomFilter
* LRU Cache

## Algorithm
* General Coding
* In-order/Pre-order/Post-order traversal
* Greedy
* Recursion/Backtrace
* Breadth-first search
* Depth-search search
* Divide and Conquer
* Dynamic Programming
* Binary Search
* Graph

## Big O Notation

* O(1): Constant Complexity: Constant常数复杂度
* O(logn):Logarithmic Complexity: 对数复杂度
* O(n): Linear Complexity: 线性时间复杂度
* O(n ^ 2): N square Complexity平方
* O(n ^ 3): N square Complexity立方
* O(2 ^ n): Exponential Growth指数
* O(n!): Factorial 阶乘

注意：只看最高复杂度的计算

## 数组、链表、跳表

数组、链表属于线性表结构，所谓线性表，就是数据排成一条线一样的结构。

## 栈、队列、优先队列、双端队列

## 哈希表、映射、集合
在建造哈希表时不仅要设定一个“好”的哈希函数，而且要设定一种处理冲突的方法。

## 树、二叉树、二叉搜索树
从链表到树的发展，你可以发现链表就是特殊化的树，而树又是特殊化的图。

* 树是如何演进的？
* 二叉搜索树原理讲解

二叉搜索树是二叉树的一种特殊形式。 二叉搜索树具有以下性质：每个节点中的值必须大于（或等于）其左侧子树中的任何值，但小于（或等于）其右侧子树中的任何值。

对于二叉搜索树，我们可以通过中序遍历得到一个递增的有序序列。因此，中序遍历是二叉搜索树中最常用的遍历方法。

## 树的遍历 - 介绍

### 前序遍历 Preorder    根-左-右

前序遍历首先访问根节点，然后遍历左子树，最后遍历右子树。

### 中序遍历 Inorder    左-根-右
中序遍历是先遍历左子树，然后访问根节点，然后遍历右子树。

对于二叉搜索树，我们可以通过中序遍历得到一个递增的有序序列。

### 后序遍历 Postorder  左-右-根

后序遍历是先遍历左子树，然后遍历右子树，最后访问树的根节点。

当你删除树中的节点时，删除过程将按照后序遍历的顺序进行。 也就是说，当你删除一个节点时，你将首先删除它的左节点和它的右边的节点，然后再删除节点本身

## 二叉搜索树
二叉搜索树主要支持三个操作：搜索、插入和删除

根据BST的特性，对于每个节点：

* 如果目标值等于节点的值，则返回节点；
* 如果目标值小于节点的值，则继续在左子树中搜索；
* 如果目标值大于节点的值，则继续在右子树中搜索。

二叉搜索树的有优点是，即便在最坏的情况下，也允许你在O(h)的时间复杂度内执行所有的搜索、插入、删除操作。

### 树结构中的常见用语

* 节点的深度 - 从树的根节点到该节点的边数
* 节点的高度 - 该节点和叶子之间最长路径上* 的边数
* 树的高度 - 其根节点的高度

一个有 N 个节点的平衡二搜索叉树的高度总是 logN。因此，我们可以计算节点总数和树的高度，以确定这个二叉搜索树是否为高度平衡的。

同样，在定义中， 我们提到了高度平衡的二叉树一个特性：每个节点的两个子树的深度不会相差超过 1。我们也可以根据这个性质，递归地验证树。

## 堆、二叉堆和图
堆是可以迅速找到一堆数中的最大或者最小值的数据结构。

## 递归、分治和回溯

树的面试题解法一般都是递归


* 解决分治问题的时候，思路就是想办法把问题的规模减小，有时候减小一个，有时候减小一半，然后将每个小问题的解以及当前的情况组合起来得出最终的结果。例如归并排序和快速排序，归并排序将要排序的数组平均地分成两半，快速排序将数组随机地分成两半。然后不断地对它们递归地进行处理。
* 这里存在有最优的子结构，即原数组的排序结果是在子数组排序的结果上* 组合出来的，但是不存在重复子问题，因为不断地对待排序的数组进行对半分的时候，两半边的数据并不重叠，分别解决左半边和右半边的两个子问题的时候，
* 没有子问题重复出现，这是动态规划和分治的区别

## 深度、广度优先搜索

* 如何用代码实现 BFS、DFS？
* BFS 和 DFS 有什么区别？
* 双向 BFS 原理剖析
* 常考面试题目精讲

## 贪心算法与二分查找

贪心算法与动态规划的不同在于，它对每个子问题的解决方案都能作出选择，并且不能回退。

### 贪心算法的原理是什么？

* 关于最优子结构

贪心：每一步的最优解一定包含上一步的最优解，上一步之前的最优解无需记录
动态规划：全局最优解中一定包含某个局部最优解，但不一定包含上一步的局部最优解，因此需要记录之前的所有的局部最优解

* 关于子问题最优解组合成原问题最优解的组合方式

贪心：如果把所有的子问题看成一棵树的话，贪心从根出发，每次向下遍历最优子树即可，这里的最优是贪心意义上的最优。此时不需要知道一个节点的所有子树情况，于是构不成一棵完整的树

动态规划：动态规划需要对每一个子树求最优解，直至下面的每一个叶子的值，最后得到一棵完整的树，在所有子树都得到最优解后，将他们组合成答案

* 结果正确性

贪心不能保证求得的最后解是最佳的，复杂度低
动态规划本质是穷举法，可以保证结果是最佳的，复杂度高


## 动态规划

递推、状态的定义、最优子结构和状态转移方程是动态规划最核心的 4 个要素。

* 动态规划的原理讲解

通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。

动态规划不是某一种具体的算法，而是一种算法思想：若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。

* 理解动态规划的关键点是什么？有哪些误区？

解决动态规划问题的核心：找出子问题及其子问题与原问题的关系

## 并查集、字典树、红黑树和 AVL 树

AVL 树是一种高度平衡的二叉树，所以查找效率非常高也比较复杂；而红黑树只做到近似平衡，所以维护成本要低一些。

## 位运算、布隆过滤器和 LRU Cache

对于一个很长的二进制向量和一系列随机函数，布隆过滤器可以用于检索一个元素是否在一个集合中。


